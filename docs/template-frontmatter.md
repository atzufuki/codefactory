# Template Frontmatter System

Factory templates can embed metadata directly using YAML or JSON frontmatter, similar to Markdown files in static site generators.

## Example

```handlebars
---
name: factory
description: Creates a new template-based factory definition
params:
  name:
    description: Unique name for the factory (e.g., 'react_component')
    required: true
  description:
    description: Human-readable description of what the factory does
    required: true
  template:
    description: Code template with {{variable}} placeholders
    required: true
  outputPath:
    description: Optional file path template (e.g., 'src/{{componentName}}.ts')
    required: false
examples:
  - name: typescript_function
    description: Creates a TypeScript function
    template: |
      export function {{functionName}}({{params}}): {{returnType}} {
        {{body}}
      }
    outputPath: src/{{functionName}}.ts
---
import { defineFactory } from "@codefactory/core";

/**
 * {{description}}
 * 
 * Generated by: factory meta-factory
 * Factory name: {{name}}
 */
export const {{factoryConstName}} = defineFactory({
  name: "{{name}}",
  description: "{{description}}",
  template: `{{template}}`,
  {{outputPathLine}}
  {{paramsBlock}}
});
```

## Template Loader

```typescript
// src/codefactory/template-loader.ts

export interface TemplateFrontmatter {
  name: string;
  description: string;
  params?: Record<string, ParamDefinition>;
  examples?: Example[];
  outputPath?: string;
}

export class TemplateLoader {
  /**
   * Load a template file and parse its frontmatter
   */
  static async loadTemplate(templatePath: string): Promise<{
    frontmatter: TemplateFrontmatter;
    template: string;
  }> {
    const content = await Deno.readTextFile(templatePath);
    const { frontmatter, body } = parseFrontmatter(content);
    return { frontmatter, template: body };
  }

  /**
   * Convert a template with frontmatter into a FactoryDefinition
   */
  static toFactoryDefinition(
    frontmatter: TemplateFrontmatter,
    template: string
  ): FactoryDefinition {
    return {
      name: frontmatter.name,
      description: frontmatter.description,
      params: frontmatter.params || {},
      examples: frontmatter.examples || [],
      generate: (params) => {
        const content = renderTemplate(template, params);
        return {
          content,
          filePath: frontmatter.outputPath
            ? renderTemplate(frontmatter.outputPath, params)
            : undefined,
        };
      },
    };
  }

  /**
   * Load all templates from a directory
   */
  static async loadDirectory(dirPath: string): Promise<FactoryDefinition[]> {
    const factories: FactoryDefinition[] = [];
    
    for await (const entry of Deno.readDir(dirPath)) {
      if (entry.isFile && (entry.name.endsWith('.hbs') || entry.name.endsWith('.template'))) {
        const templatePath = `${dirPath}/${entry.name}`;
        const { frontmatter, template } = await this.loadTemplate(templatePath);
        const factory = this.toFactoryDefinition(frontmatter, template);
        factories.push(factory);
      }
    }
    
    return factories;
  }
}
```

## Frontmatter Parser

```typescript
// src/codefactory/frontmatter.ts

export interface ParseResult<T = unknown> {
  frontmatter: T;
  body: string;
}

/**
 * Parse frontmatter from template content.
 * Supports both YAML and JSON formats.
 */
export function parseFrontmatter<T = unknown>(content: string): ParseResult<T> {
  // YAML format: ---\n...\n---
  const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n([\s\S]*)$/);
  if (yamlMatch) {
    const [, frontmatterText, body] = yamlMatch;
    const frontmatter = parseYAML(frontmatterText) as T;
    return { frontmatter, body };
  }

  // JSON format: /*---\n...\n---*/
  const jsonMatch = content.match(/^\/\*---\r?\n([\s\S]*?)\r?\n---\*\/\r?\n([\s\S]*)$/);
  if (jsonMatch) {
    const [, frontmatterText, body] = jsonMatch;
    const frontmatter = JSON.parse(frontmatterText) as T;
    return { frontmatter, body };
  }

  // No frontmatter found
  return {
    frontmatter: {} as T,
    body: content,
  };
}
```

## Supported Formats

### YAML
```yaml
---
name: my_factory
description: My factory description
params:
  componentName:
    description: Name of the component
    required: true
examples:
  - name: example1
    template: |
      Multi-line strings
      are easy in YAML
---
```

YAML is the recommended format for frontmatter.

### JSON
```json
/*---
{
  "name": "my_factory",
  "description": "My factory description",
  "params": {
    "componentName": {
      "description": "Name of the component",
      "required": true
    }
  }
}
---*/
```

JSON is supported as an alternative format.

## Usage

```typescript
import { TemplateLoader } from "@codefactory/core";

// Load all factories from directory
const factories = await TemplateLoader.loadDirectory("./factories");
for (const factory of factories) {
  registry.register(factory);
}
```

## API Reference

### Frontmatter Parser

```typescript
import { parseFrontmatter, hasFrontmatter, extractFrontmatter } from "@codefactory/core";

// Parse frontmatter
const { frontmatter, body } = parseFrontmatter<MyFrontmatter>(content);

// Check if has frontmatter
if (hasFrontmatter(content)) {
  // Has frontmatter
}

// Extract just the frontmatter text
const frontmatterText = extractFrontmatter(content);
```

### Template Loader

```typescript
import { TemplateLoader } from "@codefactory/core";

// Load single template
const { frontmatter, template } = await TemplateLoader.loadTemplate("./path/to/template.hbs");

// Convert to factory definition
const factory = TemplateLoader.toFactoryDefinition(frontmatter, template);

// Load directory
const factories = await TemplateLoader.loadDirectory("./factories");
```
