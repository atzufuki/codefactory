# Template Frontmatter System

## Status
**Proposed** - Not yet implemented

## Problem Statement

Currently, factory definitions are split between two places:
1. **TypeScript code** (`builtins.ts`) - Contains metadata like `name`, `description`, `params`, `examples`
2. **Template file** (`factory.ts.hbs`) - Contains the actual code template

This creates several issues:
- **Duplication**: Template variables must be documented separately in params
- **Maintenance burden**: Changes require updating two files
- **Cognitive overhead**: Developer must context-switch between TypeScript and template
- **Not DRY**: Factory metadata is divorced from its template

## Solution: Embedded Frontmatter in Templates

Embed all factory metadata directly in the template file using frontmatter (similar to Markdown files, Jekyll, Hugo, etc.):

```handlebars
---
name: define_factory
description: Creates a new template-based factory definition
params:
  name:
    description: Unique name for the factory (e.g., 'react_component')
    required: true
  description:
    description: Human-readable description of what the factory does
    required: true
  template:
    description: Code template with {{variable}} placeholders
    required: true
  outputPath:
    description: Optional file path template (e.g., 'src/{{componentName}}.ts')
    required: false
examples:
  - name: typescript_function
    description: Creates a TypeScript function
    template: |
      export function {{functionName}}({{params}}): {{returnType}} {
        {{body}}
      }
    outputPath: src/{{functionName}}.ts
---
import { defineFactory } from "@codefactory/core";

/**
 * {{description}}
 * 
 * Generated by: define_factory meta-factory
 * Factory name: {{name}}
 */
export const {{factoryConstName}} = defineFactory({
  name: "{{name}}",
  description: "{{description}}",
  template: `{{template}}`,
  {{outputPathLine}}
  {{paramsBlock}}
});
```

## Benefits

### ✅ Single Source of Truth
- All factory metadata in one file
- Template and metadata co-located
- Easier to understand and maintain

### ✅ Less Code
- Eliminate TypeScript wrapper in `builtins.ts`
- No manual metadata construction
- Template file is self-documenting

### ✅ Better DX
- Edit one file instead of two
- See template and params together
- Copy/paste friendly

### ✅ Auto-discovery
- Scan `factories/` directory for `.hbs` files
- Parse frontmatter automatically
- Generate `FactoryDefinition` objects on the fly

## Architecture

### Template Loader

```typescript
// src/codefactory/template-loader.ts

export interface TemplateFrontmatter {
  name: string;
  description: string;
  params?: Record<string, ParamDefinition>;
  examples?: Example[];
  outputPath?: string;
}

export class TemplateLoader {
  /**
   * Load a template file and parse its frontmatter
   */
  static async loadTemplate(templatePath: string): Promise<{
    frontmatter: TemplateFrontmatter;
    template: string;
  }> {
    const content = await Deno.readTextFile(templatePath);
    const { frontmatter, body } = parseFrontmatter(content);
    return { frontmatter, template: body };
  }

  /**
   * Convert a template with frontmatter into a FactoryDefinition
   */
  static toFactoryDefinition(
    frontmatter: TemplateFrontmatter,
    template: string
  ): FactoryDefinition {
    return {
      name: frontmatter.name,
      description: frontmatter.description,
      params: frontmatter.params || {},
      examples: frontmatter.examples || [],
      generate: (params) => {
        const content = renderTemplate(template, params);
        return {
          content,
          filePath: frontmatter.outputPath
            ? renderTemplate(frontmatter.outputPath, params)
            : undefined,
        };
      },
    };
  }

  /**
   * Load all templates from a directory
   */
  static async loadDirectory(dirPath: string): Promise<FactoryDefinition[]> {
    const factories: FactoryDefinition[] = [];
    
    for await (const entry of Deno.readDir(dirPath)) {
      if (entry.isFile && (entry.name.endsWith('.hbs') || entry.name.endsWith('.template'))) {
        const templatePath = `${dirPath}/${entry.name}`;
        const { frontmatter, template } = await this.loadTemplate(templatePath);
        const factory = this.toFactoryDefinition(frontmatter, template);
        factories.push(factory);
      }
    }
    
    return factories;
  }
}
```

### Frontmatter Parser

```typescript
// src/codefactory/frontmatter.ts

export interface ParseResult<T = unknown> {
  frontmatter: T;
  body: string;
}

/**
 * Parse frontmatter from template content.
 * Supports both YAML and JSON formats.
 */
export function parseFrontmatter<T = unknown>(content: string): ParseResult<T> {
  // YAML format: ---\n...\n---
  const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n([\s\S]*)$/);
  if (yamlMatch) {
    const [, frontmatterText, body] = yamlMatch;
    const frontmatter = parseYAML(frontmatterText) as T;
    return { frontmatter, body };
  }

  // JSON format: /*---\n...\n---*/
  const jsonMatch = content.match(/^\/\*---\r?\n([\s\S]*?)\r?\n---\*\/\r?\n([\s\S]*)$/);
  if (jsonMatch) {
    const [, frontmatterText, body] = jsonMatch;
    const frontmatter = JSON.parse(frontmatterText) as T;
    return { frontmatter, body };
  }

  // No frontmatter found
  return {
    frontmatter: {} as T,
    body: content,
  };
}
```

## Format Support

### YAML (Primary)
```yaml
---
name: my_factory
description: My factory description
params:
  componentName:
    description: Name of the component
    required: true
examples:
  - name: example1
    template: |
      Multi-line strings
      are easy in YAML
---
```

**Pros:**
- ✅ Clean, readable syntax
- ✅ Native multiline string support
- ✅ Less verbose than JSON
- ✅ Industry standard for frontmatter
- ✅ Deno has official `@std/yaml` parser

**Cons:**
- ❌ Whitespace-sensitive
- ❌ Requires YAML parser dependency

### JSON (Secondary)
```json
/*---
{
  "name": "my_factory",
  "description": "My factory description",
  "params": {
    "componentName": {
      "description": "Name of the component",
      "required": true
    }
  }
}
---*/
```

**Pros:**
- ✅ Native JavaScript/TypeScript support
- ✅ No additional dependencies
- ✅ Strict parsing (catches errors)

**Cons:**
- ❌ More verbose (quotes on keys)
- ❌ No comments
- ❌ Multiline strings require escape characters
- ❌ Trailing commas cause errors

### Recommendation
Use **YAML as the primary format** with JSON as fallback for edge cases. YAML is the standard for frontmatter in static site generators (Jekyll, Hugo, Astro, etc.) and is much more ergonomic for template metadata.

## Implementation Plan

### Phase 1: Frontmatter Parser
- [ ] Create `src/codefactory/frontmatter.ts`
- [ ] Implement `parseFrontmatter()` function
- [ ] Support both YAML and JSON formats
- [ ] Add unit tests for parser
- [ ] Add `@std/yaml` dependency

### Phase 2: Template Loader
- [ ] Create `src/codefactory/template-loader.ts`
- [ ] Implement `TemplateLoader` class
- [ ] `loadTemplate()` - Load single template with frontmatter
- [ ] `toFactoryDefinition()` - Convert to FactoryDefinition
- [ ] `loadDirectory()` - Load all templates from directory
- [ ] Add unit tests

### Phase 3: Update Built-in Factories
- [ ] Convert `builtins.ts` to use TemplateLoader
- [ ] Simplify to just: `TemplateLoader.loadDirectory('./factories')`
- [ ] Update `factory.ts.hbs` with frontmatter
- [ ] Remove manual factory construction code
- [ ] Verify all built-ins still work

### Phase 4: Template Project Updates
- [ ] Update example factories with frontmatter
- [ ] Update documentation
- [ ] Add examples of both YAML and JSON formats
- [ ] Update `create` CLI to copy new format

### Phase 5: Documentation
- [ ] Document frontmatter format in README
- [ ] Add migration guide for existing factories
- [ ] Create examples repository
- [ ] Update Copilot prompts to reference frontmatter

## Migration Path

### Old Format (TypeScript + Separate Template)
```typescript
// builtins.ts
export const myFactory: FactoryDefinition = {
  name: "my_factory",
  description: "Does something",
  params: {
    name: {
      description: "The name",
      required: true,
    },
  },
  generate: (params) => {
    const template = await loadTemplate("./templates/my-factory.hbs");
    return { content: render(template, params) };
  },
};
```

### New Format (Template with Frontmatter)
```yaml
---
name: my_factory
description: Does something
params:
  name:
    description: The name
    required: true
---
// Template content here
```

```typescript
// builtins.ts (much simpler!)
import { TemplateLoader } from "./template-loader.ts";

export const builtInFactories = await TemplateLoader.loadDirectory(
  new URL("./factories", import.meta.url).pathname
);
```

## Open Questions

1. **Template format detection**: Should we support `.hbs`, `.template`, both?
   - Proposal: Support both, detect by extension
   - `.hbs` → Handlebars syntax highlighting
   - `.ts.template` → TypeScript syntax highlighting

2. **Frontmatter validation**: How strict should validation be?
   - Proposal: Required fields: `name`, `description`
   - Optional: `params`, `examples`, `outputPath`
   - Runtime validation with helpful error messages

3. **Nested factories**: Can templates reference other templates?
   - Proposal: Phase 2 feature, not MVP
   - Use `includes` or `extends` in frontmatter

4. **Template caching**: Should parsed templates be cached?
   - Proposal: Yes, in production mode
   - Dev mode: Always reload for hot-reloading

5. **Custom frontmatter fields**: Allow user-defined metadata?
   - Proposal: Yes, store in `metadata` field
   - Pass through to factory output

## Success Metrics

- ✅ Zero-config factory definition (just drop `.hbs` file in `factories/`)
- ✅ Reduce factory boilerplate by 70%+
- ✅ Single file contains all factory logic
- ✅ Backwards compatible with existing TypeScript factories
- ✅ 100% test coverage on parser
- ✅ Documentation with 5+ examples

## Related Issues

- Relates to auto-registration (factories auto-discovered from directory)
- Enables factory marketplace (share single `.hbs` files)
- Simplifies factory testing (parse frontmatter to validate)
- Foundation for visual factory editor

## References

- Jekyll frontmatter: https://jekyllrb.com/docs/front-matter/
- Hugo frontmatter: https://gohugo.io/content-management/front-matter/
- Astro frontmatter: https://docs.astro.build/en/basics/astro-components/#the-component-script
- Gray-matter (Node.js library): https://github.com/jonschlinkert/gray-matter
- Deno YAML: https://deno.land/std/yaml
