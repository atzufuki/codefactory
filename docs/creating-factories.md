# Creating Your Own Factories

> The factory factory - build deterministic code generators for your project

## Overview

AI Code Factory includes a **meta-factory** called `factory` - a "factory factory" that lets you create new factories using simple templates. You can use it either:

1. **Via Copilot commands** (recommended) - Use `/codefactory.add` and `/codefactory.produce`
2. **Via code** (advanced) - Use the `defineFactory()` function directly

## Quick Start with Copilot Commands

The easiest way to create a factory is using the built-in `factory`:

```bash
# In VS Code with GitHub Copilot:
/codefactory.add "a 'factory' for TypeScript function with parameters and return type"

# This adds to manifest:
# - factory: factory
# - params: name="typescript_function", description="...", template="...", outputPath="..."

# Build the factory definition file
/codefactory.produce
```

This generates `factories/typescript_function.ts` - a new factory you can now use!

### Example: Creating a React Component Factory

```bash
# Step 1: Create the factory using factory
/codefactory.add "a 'factory' for functional React component with props interface and component body"

# The AI will infer:
# - name: "react_component"
# - template: with {{componentName}}, {{props}}, {{content}} variables
# - outputPath: "factories/react_component.ts"

/codefactory.produce
# â†’ Creates factories/react_component.ts

# Step 2: Use your new factory
/codefactory.add "a 'react_component' for UserCard with name and email props"

/codefactory.produce
# â†’ Creates src/components/UserCard.tsx
```

ðŸ’¡ **Tip:** The AI understands your intent and creates appropriate templates with `{{variable}}` placeholders.

## Understanding the Meta-Factory

The `factory` is itself a factory (defined in `factory.ts.hbs`) that generates other factories. When you use it:

1. **Input**: Factory name, description, and desired template structure
2. **Output**: A TypeScript file with a `defineFactory()` call
3. **Result**: A new factory ready to use in your project

### What Gets Generated

When you run `/codefactory.produce` after adding a `factory` call, you get a file like:

```typescript
// factories/react_component.ts
import { defineFactory } from "@codefactory/core";

/**
 * Creates a React functional component
 * 
 * Generated by: factory meta-factory
 * Factory name: react_component
 */
export const reactComponentFactory = defineFactory({
  name: "react_component",
  description: "Creates a React functional component",
  template: `
export interface {{componentName}}Props {
  {{#each props}}
  {{this}};
  {{/each}}
}

export function {{componentName}}(props: {{componentName}}Props) {
  return <div>{{content}}</div>;
}
  `.trim(),
  outputPath: "src/components/{{componentName}}.tsx",
});
```

## Quick Start with Code (Advanced)

## Quick Start with Code (Advanced)

If you prefer to write factory definitions directly in code:

```typescript
import { defineFactory } from "@codefactory/codefactory";

// Define a factory using template syntax
const myFactory = defineFactory({
  name: "typescript_function",
  description: "Creates a TypeScript function",
  template: `
export function {{functionName}}({{params}}): {{returnType}} {
  {{body}}
}
  `.trim(),
  outputPath: "src/{{functionName}}.ts",
});

// Use the factory
const result = await myFactory.execute({
  functionName: "calculateTotal",
  params: "items: number[]",
  returnType: "number",
  body: "return items.reduce((sum, n) => sum + n, 0);",
});

console.log(result.code);
// Output:
// export function calculateTotal(items: number[]): number {
//   return items.reduce((sum, n) => sum + n, 0);
// }
```

**Note:** This approach requires writing TypeScript code. Most users should use the Copilot commands instead.

## The `defineFactory()` Function

## The `defineFactory()` Function

The `defineFactory()` function (used in generated factory files) takes a simplified template-based definition:

### Basic Structure

```typescript
const myFactory = defineFactory({
  name: "factory_name",           // Unique identifier
  description: "What it does",    // Human-readable description
  template: "...",                // Template with {{placeholders}}
  outputPath: "...",              // Optional: where to save (can use {{vars}})
});
```

This function is what the `factory` meta-factory uses internally to create your factories.

## Template Syntax

### Variables

Use `{{variableName}}` for simple text replacement:

```typescript
template: `
export class {{className}} {
  constructor(public {{propName}}: {{propType}}) {}
}
`
```

### Triple Braces for HTML/Special Characters

Use `{{{variableName}}}` to prevent HTML escaping:

```typescript
template: `
const html = {{{htmlContent}}};  // Won't escape < > &
`
```

### Conditionals

Use `{{#if variable}}...{{/if}}` for optional sections:

```typescript
template: `
export class {{className}} {
  {{#if withConstructor}}
  constructor(public name: string) {}
  {{/if}}
}
`
```

### Loops

Use `{{#each array}}...{{/each}}` for repeating sections:

```typescript
template: `
export interface {{interfaceName}} {
  {{#each properties}}
  {{this.name}}: {{this.type}};
  {{/each}}
}
`
```

## Complete Examples

### 1. React Component Factory

```typescript
const reactComponentFactory = defineFactory({
  name: "react_component",
  description: "Creates a React functional component with TypeScript",
  template: `
import React from 'react';

export interface {{componentName}}Props {
  {{#each props}}
  {{this}};
  {{/each}}
}

export function {{componentName}}(props: {{componentName}}Props) {
  {{#each stateVars}}
  const [{{this.name}}, set{{this.capitalizedName}}] = React.useState<{{this.type}}>({{this.initialValue}});
  {{/each}}

  return (
    <div className="{{kebabCase componentName}}">
      {{content}}
    </div>
  );
}
  `.trim(),
  outputPath: "src/components/{{componentName}}.tsx",
});

// Use it
const result = await reactComponentFactory.execute({
  componentName: "UserCard",
  props: ["name: string", "email: string"],
  stateVars: [
    { name: "isExpanded", capitalizedName: "IsExpanded", type: "boolean", initialValue: "false" }
  ],
  content: "<h2>{props.name}</h2><p>{props.email}</p>",
});
```

### 2. API Endpoint Factory

```typescript
const apiEndpointFactory = defineFactory({
  name: "api_endpoint",
  description: "Creates a REST API endpoint with Deno",
  template: `
import { Router } from "oak";

export const {{handlerName}}Router = new Router();

{{handlerName}}Router.{{method}}("{{path}}", async (ctx) => {
  {{#if hasAuth}}
  const user = await authenticate(ctx);
  if (!user) {
    ctx.response.status = 401;
    return;
  }
  {{/if}}

  {{#if hasValidation}}
  const body = await ctx.request.body().value;
  const validationResult = validate{{capitalizedHandler}}(body);
  if (!validationResult.success) {
    ctx.response.status = 400;
    ctx.response.body = { errors: validationResult.errors };
    return;
  }
  {{/if}}

  // Handler implementation
  {{handlerBody}}
});
  `.trim(),
  outputPath: "src/api/{{handlerName}}.ts",
});
```

### 3. Database Model Factory

```typescript
const dbModelFactory = defineFactory({
  name: "database_model",
  description: "Creates a database model with Prisma-like syntax",
  template: `
export interface {{modelName}} {
  id: string;
  {{#each fields}}
  {{this.name}}: {{this.type}}{{#if this.optional}}?{{/if}};
  {{/each}}
  createdAt: Date;
  updatedAt: Date;
}

export class {{modelName}}Repository {
  constructor(private db: Database) {}

  async findById(id: string): Promise<{{modelName}} | null> {
    return this.db.query("SELECT * FROM {{tableName}} WHERE id = ?", [id]);
  }

  async create(data: Omit<{{modelName}}, "id" | "createdAt" | "updatedAt">): Promise<{{modelName}}> {
    const now = new Date();
    const id = crypto.randomUUID();
    return this.db.query(
      "INSERT INTO {{tableName}} ({{fieldsList}}) VALUES ({{placeholders}})",
      [id, {{fieldValues}}, now, now]
    );
  }

  {{#if withUpdate}}
  async update(id: string, data: Partial<{{modelName}}>): Promise<{{modelName}}> {
    const now = new Date();
    return this.db.query(
      "UPDATE {{tableName}} SET {{updateFields}}, updatedAt = ? WHERE id = ?",
      [...Object.values(data), now, id]
    );
  }
  {{/if}}

  {{#if withDelete}}
  async delete(id: string): Promise<void> {
    await this.db.query("DELETE FROM {{tableName}} WHERE id = ?", [id]);
  }
  {{/if}}
}
  `.trim(),
  outputPath: "src/models/{{modelName}}.ts",
});
```

### 4. Test Suite Factory

```typescript
const testSuiteFactory = defineFactory({
  name: "test_suite",
  description: "Creates a Deno test suite for a module",
  template: `
import { assertEquals, assertExists } from "@std/assert";
import { {{moduleName}} } from "./{{moduleName}}.ts";

Deno.test("{{moduleName}} - {{testDescription}}", async (t) => {
  {{#each testCases}}
  await t.step("{{this.description}}", () => {
    {{this.setup}}
    
    const result = {{this.action}};
    
    {{this.assertion}};
  });
  {{/each}}
});
  `.trim(),
  outputPath: "src/{{moduleName}}.test.ts",
});
```

## Using Factories in Manifest Workflow

Once you've created factories (using `factory` or code), use them via Copilot:

```bash
# Add factory call to manifest
/codefactory.add "a 'react_component' for UserCard with name and email props"

# This adds to manifest:
# - factory: react_component
# - params: componentName="UserCard", props=["name: string", "email: string"]

# Build from manifest
/codefactory.produce
# â†’ Generates src/components/UserCard.tsx
```

Or use the API directly:

```typescript
import { ManifestManager } from "@codefactory/codefactory";

const manager = await ManifestManager.load("./codefactory.manifest.json");

// Add factory call to manifest
manager.addFactoryCall({
  id: "user-card-component",
  factory: "react_component",  // Your custom factory
  params: {
    componentName: "UserCard",
    props: ["name: string", "email: string"],
    content: "<h2>{props.name}</h2>",
  },
  outputPath: "src/components/UserCard.tsx",
});

await manager.save();

// Build later with /codefactory.produce
```

## Organizing Factories

### Project Structure

```
my-project/
â”œâ”€â”€ factories/
â”‚   â”œâ”€â”€ index.ts              # Export all factories
â”‚   â”œâ”€â”€ components.ts         # Component factories
â”‚   â”œâ”€â”€ api.ts                # API endpoint factories
â”‚   â””â”€â”€ database.ts           # Database model factories
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/          # Generated components
â”‚   â”œâ”€â”€ api/                 # Generated endpoints
â”‚   â””â”€â”€ models/              # Generated models
â””â”€â”€ codefactory.manifest.json
```

### factories/index.ts

```typescript
import { FactoryRegistry } from "@codefactory/codefactory";
import { reactComponentFactory } from "./components.ts";
import { apiEndpointFactory } from "./api.ts";
import { dbModelFactory } from "./database.ts";

export const registry = new FactoryRegistry();

registry.register(reactComponentFactory);
registry.register(apiEndpointFactory);
registry.register(dbModelFactory);

// Or use auto-registration
await registry.autoRegister("./factories");
```

### factories/components.ts

```typescript
import { defineFactory } from "@codefactory/codefactory";

export const reactComponentFactory = defineFactory({
  name: "react_component",
  description: "Creates a React functional component",
  template: `...`,
  outputPath: "src/components/{{componentName}}.tsx",
});

export const reactHookFactory = defineFactory({
  name: "react_hook",
  description: "Creates a custom React hook",
  template: `...`,
  outputPath: "src/hooks/{{hookName}}.ts",
});
```

## Advanced: Programmatic Factories

For more complex logic, create factories programmatically:

```typescript
import { Factory } from "@codefactory/codefactory";

export const advancedFactory = new Factory({
  name: "advanced_component",
  description: "Component with complex logic",
  
  // Custom validation
  validate(params: Record<string, unknown>) {
    if (typeof params.name !== "string") {
      throw new Error("name must be a string");
    }
    if (params.name.length < 3) {
      throw new Error("name must be at least 3 characters");
    }
  },
  
  // Custom generation logic
  async execute(params: Record<string, unknown>) {
    const { name, features } = params as { name: string; features: string[] };
    
    // Complex logic here
    const imports = features.includes("state") 
      ? "import React, { useState } from 'react';"
      : "import React from 'react';";
    
    const code = `
${imports}

export function ${name}() {
  ${features.includes("state") ? "const [count, setCount] = useState(0);" : ""}
  
  return <div>${name}</div>;
}
    `.trim();
    
    return {
      code,
      outputPath: `src/components/${name}.tsx`,
    };
  },
});
```

## Best Practices

### âœ… Do

- **Keep templates simple** - Complex logic belongs in programmatic factories
- **Use descriptive names** - `react_component` not `rc`
- **Document parameters** - Help AI and users understand what's needed
- **Provide examples** - Show how to use the factory
- **Version factories** - Track changes over time

### âŒ Don't

- **Don't put business logic in templates** - Templates are for structure
- **Don't make params too granular** - `props: string[]` not `prop1: string, prop2: string...`
- **Don't hardcode values** - Use parameters instead
- **Don't duplicate** - Compose factories instead

## Helper Functions

### String Transformations

```typescript
// Built-in helpers (if implemented)
{{pascalCase variableName}}    // userCard â†’ UserCard
{{camelCase variableName}}     // user-card â†’ userCard
{{kebabCase variableName}}     // UserCard â†’ user-card
{{snakeCase variableName}}     // UserCard â†’ user_card
{{upperCase variableName}}     // usercard â†’ USERCARD
```

### Custom Helpers

```typescript
import Handlebars from "handlebars";

Handlebars.registerHelper("plural", (word: string) => {
  return word.endsWith("s") ? word : word + "s";
});

// Use in template
template: `
export class {{className}} {
  private {{plural itemName}}: {{itemType}}[] = [];
}
`
```

## Testing Factories

```typescript
import { assertEquals } from "@std/assert";

Deno.test("react_component factory", async () => {
  const result = await reactComponentFactory.execute({
    componentName: "TestButton",
    props: ["label: string"],
    content: "<button>{props.label}</button>",
  });
  
  assertEquals(result.outputPath, "src/components/TestButton.tsx");
  assert(result.code.includes("export function TestButton"));
  assert(result.code.includes("label: string"));
});
```

## GitHub Copilot Integration

### Creating Factories with Copilot

Use the `factory` meta-factory via natural language:

```bash
# Create a new factory
/codefactory.add "a 'factory' for REST API endpoint with method, path, and handler"

# AI infers the template structure and adds to manifest
/codefactory.produce
# â†’ Creates factories/api_endpoint.ts
```

### Using Your Factories

Once factories are defined, use them naturally:

```bash
# Use your custom factory
/codefactory.add "a 'react_component' for UserProfile with name and avatar props"
/codefactory.produce
# â†’ Generates src/components/UserProfile.tsx

# Use with dependencies
/codefactory.add "a 'react_component' for UserList that uses UserProfile"
/codefactory.produce
# â†’ Generates src/components/UserList.tsx
```

### Full Example Workflow

```bash
# Step 1: Create factory definitions
/codefactory.add "a 'factory' for functional React component"
/codefactory.add "a 'factory' for React hook"
/codefactory.add "a 'factory' for test suite"
/codefactory.produce
# â†’ Creates factories/react_component.ts, react_hook.ts, test_suite.ts

# Step 2: Use your factories
/codefactory.add "a 'react_component' for Button with label and onClick"
/codefactory.add "a 'react_hook' for useLocalStorage with key and initialValue"
/codefactory.add "a 'test_suite' for Button component"
/codefactory.produce
# â†’ Generates components, hooks, and tests
```

## Next Steps

- **Create factory catalog** - Document all your factories in one place
- **Share with team** - Commit factories to Git
- **Iterate and improve** - Refine based on usage
- **Compose factories** - Build complex generators from simple ones

## Related Documentation

- [Build Manifest System](./manifest-system.md) - Two-phase workflow
- [Template System](./template-frontmatter.md) - Frontmatter and template syntax
- [Auto-Registration](./auto-registration.md) - Automatic factory discovery

---

**Remember:** Factories are about **encoding your team's patterns** so AI can follow them deterministically. Define once, generate consistently forever.
